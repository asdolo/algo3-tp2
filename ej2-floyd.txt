// C Program for Floyd Warshall Algorithm 
#include<stdio.h> 

// Number of vertices in the graph 
#define V 3

/* Define Infinite as a large enough value. This value will be used 
for vertices not connected to each other */
#define INF 99999 

// A function to print the solution matrix 
void printSolution(double dist[][V]); 
void printSolution2(int dist[][V]); 

// Solves the all-pairs shortest path problem using Floyd Warshall algorithm 
void floydWarshall (double graph[][V]) 
{ 
	/* dist[][] will be the output matrix that will finally have the shortest 
	distances between every pair of vertices */
	double dist[V][V];
	int next[V][V];
	int i, j, k; 

	/* Initialize the solution matrix same as input graph matrix. Or 
	we can say the initial values of shortest distances are based 
	on shortest paths considering no intermediate vertex. */
	for (i = 0; i < V; i++) 
		for (j = 0; j < V; j++)
		    {
		        dist[i][j] = graph[i][j]; 
		        next[i][j] = j;
		    }
			

	/* Add all vertices one by one to the set of intermediate vertices. 
	---> Before start of an iteration, we have shortest distances between all 
	pairs of vertices such that the shortest distances consider only the 
	vertices in set {0, 1, 2, .. k-1} as intermediate vertices. 
	----> After the end of an iteration, vertex no. k is added to the set of 
	intermediate vertices and the set becomes {0, 1, 2, .. k} */
	for (k = 0; k < V; k++) 
	{ 
		// Pick all vertices as source one by one 
		for (i = 0; i < V; i++) 
		{ 
			// Pick all vertices as destination for the 
			// above picked source 
			for (j = 0; j < V; j++) 
			{ 
				// If vertex k is on the shortest path from 
				// i to j, then update the value of dist[i][j] 
				if (dist[i][k] * dist[k][j] > dist[i][j])
				{
				    dist[i][j] = dist[i][k] * dist[k][j];
				    next[i][j] = next[i][k];
				}
					
			} 
		} 
	} 

	// Print the shortest distance matrix 
	printSolution(dist);
	printSolution2(next);
} 

/* A utility function to print solution */
void printSolution(double dist[][V]) 
{ 
	printf ("The following matrix shows the shortest distances"
			" between every pair of vertices \n"); 
	for (int i = 0; i < V; i++) 
	{ 
		for (int j = 0; j < V; j++) 
		{ 
			if (dist[i][j] == INF) 
				printf("%7s ", "INF"); 
			else
				printf ("%7f ", dist[i][j]); 
		} 
		printf("\n"); 
	} 
}


void printSolution2(int dist[][V]) 
{ 
	printf ("The following matrix shows the shortest distances"
			" between every pair of vertices \n"); 
	for (int i = 0; i < V; i++) 
	{ 
		for (int j = 0; j < V; j++) 
		{ 
			if (dist[i][j] == INF) 
				printf("%7s ", "INF"); 
			else
				printf ("%7d ", dist[i][j]); 
		} 
		printf("\n"); 
	} 
} 

// driver program to test above function 
int main() 
{ 
	/* Let us create the following weighted graph 
			10 
	(0)------->(3) 
		|		 /|\ 
	5 |		 | 
		|		 | 1 
	\|/		 | 
	(1)------->(2) 
			3		 */
	double graph[V][V] = { {1, 1.15, 42.93},    // EURO A...
						{0.2, 1, 37.36},       // DOLAR A...
						{0.023, 0.027, 1},   // ARS A...
					}; 
			

	// Print the solution 
	floydWarshall(graph); 
	return 0; 
} 